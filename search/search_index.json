{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":""},{"location":"2024/10/01/integrating-jooqhttpswwwjooqorg-with-spring-data/","title":"Integrating Jooq with Spring Data","text":"<p>In this post, we will explore the jooq-utils library, which provides seamless integration between Spring Data and Jooq. With jooq-utils, you can retrieve data using Jooq and get a <code>org.springframework.data.domain.Page</code> object as a result, and easily use <code>org.springframework.data.domain.Pageable</code> as input for repository methods.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooqhttpswwwjooqorg-with-spring-data/#overview","title":"Overview","text":"<p>The <code>jooq-utils</code> library simplifies the pagination of Jooq results by enabling you to:</p> <ul> <li>Use Spring Data\u2019s <code>Pageable</code>   in your Jooq queries.</li> <li>Return paginated results in the form of <code>Page&lt;T&gt;</code>.</li> </ul> <p>This is especially useful in Spring-based applications that use Jooq for database interaction, where you need to integrate the pagination functionality of Spring Data.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooqhttpswwwjooqorg-with-spring-data/#sample-code","title":"Sample Code","text":"<p>Let\u2019s walk through a sample use case to show how this library can be applied in your projects.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooqhttpswwwjooqorg-with-spring-data/#1-create-the-repository","title":"1. Create the Repository","text":"<pre><code>import org.jooq.Condition\nimport org.springframework.data.domain.Page\nimport org.springframework.data.domain.Pageable\nimport org.springframework.stereotype.Component\nimport org.dema.Tables.USERS\nimport org.dema.jooq.AbstractRepository\nimport org.dema.jooq.JooqUtils\n\n@Component\nclass UsersRepository : AbstractRepository&lt;Users, UsersRecord&gt;(table = USERS) {\n\n  fun getPageBy(pageable: Pageable, condition: Condition): Page&lt;UsersRecord&gt; {\n    val query = baseQuery({ condition })\n    return JooqUtils.paginate(dsl, query, pageable, USERS)\n  }\n\n  private fun baseQuery(vararg where: (Users) -&gt; Condition): SelectConditionStep&lt;UsersRecord&gt; {\n    return dsl.selectFrom(USERS)\n      .where(foldConditions(where))\n  }\n}\n</code></pre> <p>In the above code:</p> <p>We define a <code>UsersRepository</code> class that extends <code>AbstractRepository</code>. The <code>getPageBy()</code> method allows pagination of the user records based on the provided Condition and Pageable parameters. The actual pagination logic is handled by <code>JooqUtils.paginate()</code>.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooqhttpswwwjooqorg-with-spring-data/#2-use-the-repository-in-a-service","title":"2. Use the Repository in a Service","text":"<pre><code>import org.jooq.Condition\nimport org.jooq.impl.DSL.noCondition\nimport org.springframework.data.domain.Page\nimport org.springframework.data.domain.Pageable\nimport org.springframework.stereotype.Service\nimport org.springframework.core.convert.ConversionService\nimport org.springframework.transaction.annotation.Transactional\n\n@Service\n@Transactional(readOnly = true)\nclass UsersService(\n  @Qualifier(\"mvcConversionService\") private val cs: ConversionService,\n  private val usersRepository: UsersRepository,\n) {\n\n  fun search(filter: UsersFilter, pageable: Pageable): UsersPage {\n    val filterCondition: Condition = filter?.let(cs::convert) ?: noCondition()\n    val userRecordsPage: Page&lt;UsersRecord&gt; = usersRepository.getPageBy(pageable, filterCondition)\n    return cs.convert(userRecordsPage)!!\n  }\n}\n</code></pre> <p>In the UsersService class:</p> <ul> <li>We define a <code>search()</code> method that receives a <code>UsersFilter</code> and a <code>Pageable</code>.</li> <li>The service converts the <code>filter</code> into a <code>Condition</code>, which is passed to the repository method <code>getPageBy()</code>.</li> <li>The paginated result is returned as a <code>UsersPage</code> after conversion.</li> </ul>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooqhttpswwwjooqorg-with-spring-data/#3-conclusion","title":"3. Conclusion","text":"<p>You now have a working example of integrating Spring Data\u2019s pagination functionality into Jooq using jooq-utils. The provided repository and service examples demonstrate how to handle pagination in your Jooq queries with minimal code changes.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/","title":"How to generate Interactive Database Documentation with SchemaSpy and Gradle","text":"<p>Gradle plugin that lets you generate database documentation using Schemaspy and Testcontainers</p>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/#overview","title":"Overview","text":"<p>The schemaspy-gradle-plugin allows you to generate database documentation via DDL. Let`s consider an example. In the example I'll use postgres sakila schema.</p> <p>The plugin uses the following tools:</p> <ul> <li>SchemaSpy is a tool that generates interactive database documentation by analyzing your database schema. It's   especially useful for visualizing relationships between tables and understanding the overall structure of the   database.</li> <li>Gradle is a versatile build tool that automates the process of building, testing, and deploying software. Here, we use   it to integrate SchemaSpy easily into our build workflow.</li> <li>Testcontainers is a Java library that provides throwaway instances of databases (among other things) for integration   testing. In this context, it allows you to run a real instance of your database for generating documentation.</li> </ul> <p>These tools together allow you to automate the creation of up-to-date database documentation within your CI/CD pipeline, ensuring that developers and analysts always have the latest version available.</p>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/#how-to-use","title":"How to use","text":"<ol> <li>Add dependency:    <pre><code>plugins {\n id(\"io.github.denis-markushin.schemaspy-plugin\")\n}\n</code></pre></li> <li>Configure the plugin using an extension:    <pre><code>schemaspyConfig {\n  dbName = \"sakila\"\n  liquibaseChangelog = file(\"${project.projectDir}/src/main/resources/liquibase/changelog.yml\")\n  outputDir = project.layout.buildDirectory.dir(\"schemaspy/sakila\")\n}\n</code></pre></li> <li>Run <code>gradle generateSchemaspyDocs</code>.</li> <li> <p>Get output in gradle <code>build/schemaspy/db/output</code> folder.    </p> <p>Note</p> <p>Open <code>build/schemaspy/sakila/output/index.html</code> locally</p> </li> </ol>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/#plugin-configuration-breakdown","title":"Plugin Configuration Breakdown","text":"<p>Let\u2019s break down the configuration steps in more detail to clarify the purpose of each setting:</p> <ol> <li><code>dbName</code>:    This property specifies the name of the database for which you want to generate the documentation. In our example,    it's set to \"sakila\" (a sample database for practice).</li> <li><code>liquibaseChangelog</code>:    This refers to the path of the Liquibase changelog file. Liquibase is a tool for managing database schema changes. By    specifying the changelog file here, the plugin can track and apply any updates to your database schema before    generating the documentation.</li> <li>postgresDockerImage:    The plugin uses Docker to run a PostgreSQL instance for generating the database documentation. This property allows    you to define which version of the PostgreSQL image to use. By default, it\u2019s set to \"postgres:13.5-alpine\", but you    can customize it if needed.</li> <li><code>schemaspyDockerImage</code>:    This defines the Docker image for SchemaSpy itself, which will be used to generate the interactive documentation. The    default value is \"schemaspy/schemaspy:6.1.0\", ensuring you're using a specific version of SchemaSpy.</li> <li><code>excludeTables</code>:    This property specifies tables that should be excluded from the documentation generation. By default, it excludes    Liquibase\u2019s internal tables like \"databasechangeloglock\" and \"databasechangelog\", as they are not relevant for schema    documentation purposes.</li> <li><code>unzipOutput</code>:    A boolean property that determines whether the output should be unzipped or not after the documentation is generated.    The default value is true, which means the documentation files will be unzipped for easier access.</li> <li><code>outputDir</code>:    This property defines the directory where the generated SchemaSpy output will be saved. You can specify any directory    of your choice, but in this case, it\u2019s configured to the build/schemaspy/sakila folder.</li> </ol> <p>These settings provide a lot of flexibility, allowing you to customize the plugin\u2019s behavior according to your project\u2019s requirements.</p>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/#conclusion","title":"Conclusion","text":"<p>Using the SchemaSpy Gradle plugin, you can effortlessly generate comprehensive database documentation. This documentation is not only beneficial for analytics but also serves various other purposes:</p> <ul> <li>For Developers: It helps developers understand the database structure, relationships, and dependencies, making it   easier to work with the data layer.</li> <li>For Testers: Testers can refer to the documentation to create effective test cases based on the actual database   schema and its constraints.</li> <li>For Compliance: Regulatory compliance often requires detailed documentation of data structures. This plugin   facilitates adherence to such requirements by providing clear and updated documentation.</li> </ul> <p>Additionally, you can integrate this process into your CI/CD pipeline to ensure that documentation is automatically generated and deployed to platforms like GitLab or GitHub, keeping your team aligned with the latest schema changes.</p> <p>The full example can be found on GitHub.</p>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/","title":"How to Use Virtual Threads in DGS","text":"<p>In this post, I\u2019ll explain how to use virtual threads with Netflix DGS in a GraphQL application. While exploring this feature, I encountered several undocumented challenges and found solutions that I\u2019m excited to share.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#overview","title":"Overview","text":"<p>The DataLoader pattern is essential for solving the N + 1 problem in GraphQL. The DGS Framework provides a convenient <code>@DgsDataLoader</code> annotation for implementing DataLoaders.</p> <p>To handle batched loading, I implemented the  <code>org.dataloader.MappedBatchLoader</code> interface. <code>MappedBatchLoader</code> is ideal when not all keys are expected to have values, as it creates a <code>Map</code> of key/values for a <code>Set</code> of keys rather than a <code>List</code> for a <code>List</code>.</p> <p>Additionally, DGS introduced virtual threads to improve concurrency. Below, I\u2019ll explain the steps I followed, the challenges I faced, and how I resolved them.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#sample-code","title":"Sample Code","text":"","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#implementing-a-dataloader","title":"Implementing a DataLoader","text":"<p>The <code>@DgsDataLoader</code> annotation simplifies creating DataLoaders. Here's my implementation:</p> <pre><code>@DgsDataLoader(caching = true)\nclass UsersDataLoader(\n  private val usersService: UsersService,\n  private val dgsAsyncTaskExecutor: Executor,\n) : MappedBatchLoader&lt;String, User?&gt; {\n\n  override fun load(ids: Set&lt;String&gt;): CompletionStage&lt;Map&lt;String, User?&gt;&gt; {\n    return CompletableFuture.supplyAsync({\n      usersService.getAllByUserIds(ids)\n        .associateBy { it.id }\n        .let { resultMap -&gt; keys.associateWith { resultMap[it] } }\n    }, dgsAsyncTaskExecutor)\n  }\n}\n</code></pre> <p>This implementation ensures efficient batching and mapping using <code>MappedBatchLoader</code>.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#virtual-threads-in-dgs","title":"Virtual Threads in DGS","text":"","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#enabling-virtual-threads","title":"Enabling Virtual Threads","text":"<p>DGS Framework supports using virtual threads through a simple property:</p> <pre><code>dgs.graphql.virtualthreads.enabled=true\n</code></pre> <p>When enabled, each user-defined data fetcher executes in a new virtual thread, as confirmed by logs like:</p> <pre><code>2024-12-11 22:51:29.494 +0300 [,,] [dgs-virtual-thread-2] INFO [Logger] : #getById(...) in 389.88ms\n</code></pre>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#issue-with-spring-security","title":"Issue with Spring Security","text":"<p>However, when integrating Spring Security, if you use <code>@PreAuthorize</code>\\<code>@Secured</code>\\etc. for access control, you might encounter issues with context propagation. I encountered the following error:</p> <pre><code>An Authentication object was not found in the SecurityContext\n</code></pre> <p>This occurs because virtual threads do not automatically propagate the <code>SecurityContext</code>. For details, see the Spring Security documentation.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#fixing-security-context-propagation","title":"Fixing Security Context Propagation","text":"<p>The <code>DgsAutoConfiguration</code> class declares a bean for an <code>AsyncTaskExecutor</code> when the property <code>dgs.graphql.virtualthreads.enabled</code> is set to <code>true</code>:</p> <pre><code>@Bean\n@Qualifier(\"dgsAsyncTaskExecutor\")\n@ConditionalOnJava21\n@ConditionalOnMissingBean(name = [\"dgsAsyncTaskExecutor\"])\n@ConditionalOnProperty(name = [\"dgs.graphql.virtualthreads.enabled\"], havingValue = \"true\", matchIfMissing = false)\nopen fun virtualThreadsTaskExecutor(contextRegistry: ContextRegistry): AsyncTaskExecutor {\n  LOG.info(\"Enabling virtual threads for DGS\")\n  val contextSnapshotFactory = ContextSnapshotFactory.builder().contextRegistry(contextRegistry).build()\n  return VirtualThreadTaskExecutor(contextSnapshotFactory)\n}\n</code></pre> <p>However, this default <code>AsyncTaskExecutor</code> does not propagate the <code>SecurityContext</code>. To ensure compatibility with Spring Security, I wrapped it in a <code>DelegatingSecurityContextAsyncTaskExecutor</code>.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#custom-configuration","title":"Custom Configuration","text":"<p>Here\u2019s the updated configuration:</p> <pre><code>@Configuration(proxyBeanMethods = false)\nclass AsyncExecutorConfig {\n\n  @Bean\n  fun dgsAsyncTaskExecutor(contextRegistry: ContextRegistry): AsyncTaskExecutor {\n    log.info(\"Enabling virtual threads for DGS\")\n    val contextSnapshotFactory = ContextSnapshotFactory.builder().contextRegistry(contextRegistry).build()\n    return DelegatingSecurityContextAsyncTaskExecutor(VirtualThreadTaskExecutor(contextSnapshotFactory))\n  }\n}\n</code></pre> <p>This ensures that the security context is properly propagated while using virtual threads.</p> <p>Note</p> <p>If you enable <code>dgs.graphql.virtualthreads.enabled=true</code>, you must disable this property to avoid conflicts with the <code>DgsAutoConfiguration</code>-provided bean that does not propagate the <code>SecurityContext</code>.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#results","title":"Results","text":"<p>After applying these changes, my Data Fetchers run seamlessly on virtual threads while maintaining proper security context propagation. Logs show improved execution:</p> <pre><code>2024-12-11 22:51:30.496 +0300 [,,] [dgs-virtual-thread-4] INFO [Logger] : #getAllByIds(['1', '2']): [...] in 140.02ms\n</code></pre>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#conclusion","title":"Conclusion","text":"<p>Using virtual threads in DGS can significantly enhance concurrency. However, for projects with Spring Security, additional configuration is required to propagate the <code>SecurityContext</code>. The steps outlined above should help you integrate this effectively and make the most of virtual threads in your GraphQL applications.</p>","tags":["Kotlin","DGS"]},{"location":"archive/2024/","title":"2024","text":""},{"location":"category/kotlin/","title":"Kotlin","text":""},{"location":"category/dgs/","title":"DGS","text":""},{"location":"category/plugins/","title":"Plugins","text":""},{"location":"category/jooq/","title":"Jooq","text":""}]}